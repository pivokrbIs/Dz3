# **Отчет о лабораторной работе и модульном домашнем задании N2**

## **Введение**
Целью работы была разработка программы на языке C++, вычисляющей значение математического выражения, введенного пользователем в инфиксной форме. Программа поддерживает базовые арифметические операции, тригонометрические и экспоненциальные функции, переменную x, а также проверяет корректность введенного выражения.

## **Часть 1. Структура проекта**
Проект реализован в одном файле и содержит следующие основные компоненты:
- Функции проверки корректности выражения
- Функции преобразования в обратную польскую запись (RPN)
- Функции вычисления выражения по RPN
- Вспомогательные функции для работы с операторами и функциями

## **Часть 2. Реализация проверки корректности выражения**
Функция `bool checkExpression(const std::string& expr)` проверяет корректность введенного математического выражения. Она выполняет следующие проверки:

1. **Соответствие скобок** - проверяет, что каждой открывающей скобке соответствует закрывающая
2. **Корректность символов** - допускает только цифры, операторы, точку, скобки, переменную x и буквы для функций
3. **Правильная последовательность** - проверяет, что операторы и операнды чередуются корректно

```cpp
bool checkExpression(const std::string& expr) {
    std::stack<char> brackets;
    // ... проверка всех условий корректности
    return brackets.empty() && !expectingOperand;
}
```

## **Часть 3. Реализация преобразования в обратную польскую запись**
Функция `std::queue<std::string> toRPN(const std::string& expr, double x)` преобразует инфиксное выражение в постфиксную форму (RPN) с использованием алгоритма сортировочной станции:

1. **Обработка чисел и переменных** - числа и значение переменной x добавляются напрямую в выходную очередь
2. **Обработка функций** - имена функций помещаются в стек операторов
3. **Обработка операторов** - операторы помещаются в стек с учетом приоритета
4. **Обработка скобок** - скобки управляют порядком извлечения операторов из стека

```cpp
while (!opStack.empty() && opStack.top() != "(" &&
       ((opStack.top() == "~") ||
        (isOperator(opStack.top()[0]) && getPriority(opStack.top()[0]) >= getPriority(c)))) {
    output.push(opStack.top());
    opStack.pop();
}
```

## **Часть 4. Реализация вычисления выражения**
Функция `double calculateRPN(std::queue<std::string> rpn)` вычисляет значение выражения, представленного в обратной польской записи:

1. **Использование стека** - для хранения промежуточных результатов
2. **Обработка чисел** - числа помещаются в стек
3. **Обработка функций** - унарные функции применяются к верхнему элементу стека
4. **Обработка операторов** - бинарные операторы применяются к двум верхним элементам стека
5. **Обработка унарного минуса** - специальный токен "~" для отрицательных чисел

```cpp
if (isFunction(token)) {
    double val = calcStack.top();
    calcStack.pop();
    
    if (token == "sin") val = std::sin(val);
    else if (token == "cos") val = std::cos(val);
    // ... остальные функции
    calcStack.push(val);
}
```

## **Часть 5. Вспомогательные функции**
Программа использует несколько вспомогательных функций:
- `bool isOperator(char c)` - проверяет, является ли символ оператором
- `bool isFunction(const std::string& s)` - проверяет, является ли строка поддерживаемой функцией
- `int getPriority(char op)` - возвращает приоритет оператора для определения порядка вычислений

**Часть 6. Работа основного алгоритма**
В функции `main()` реализована следующая последовательность действий:
1. Ввод математического выражения
2. Проверка корректности выражения
3. Запрос значения переменной x (если она присутствует в выражении)
4. Преобразование выражения в RPN
5. Вычисление результата
6. Вывод результата

```cpp
int main() {
    std::string expression;
    std::cout << "Enter expression: ";
    std::getline(std::cin, expression);
    
    // Проверка корректности
    if (!checkExpression(expression)) {
        std::cout << "Error: Invalid expression." << std::endl;
        return 1;
    }
    
    // Запрос значения x
    double x = 0;
    bool hasX = expression.find('x') != std::string::npos;
    if (hasX) {
        std::cout << "Enter x = ";
        std::cin >> x;
    }
    
    // Преобразование и вычисление
    std::queue<std::string> rpn = toRPN(expression, x);
    double result = calculateRPN(rpn);
    
    std::cout << "Result: " << result << std::endl;
    
    return 0;
}
```

## **Часть 7. Вывод**
В ходе выполнения работы был разработан строковый калькулятор, который:
1. Корректно обрабатывает математические выражения со скобками
2. Поддерживает тригонометрические функции (sin, cos, tg, ctg) и экспоненту (exp)
3. Работает с переменной x
4. Выполняет проверку корректности введенного выражения
5. Вычисляет результат с учетом приоритета операций

Программа демонстрирует практическое применение:
- Алгоритма преобразования в обратную польскую запись
- Стеков для обработки математических выражений
- Обработки строк и синтаксического анализа
- Математических функций стандартной библиотеки C++

Работа успешно соответствует всем требованиям задания.
